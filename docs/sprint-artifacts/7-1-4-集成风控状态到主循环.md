# Story 7.1.4: 集成风控状态到主循环

Status: done

## Story

As a **system**,  
I want **risk control state to be integrated into the main trading loop and checked on every iteration**,  
so that **risk limits can be enforced in real-time and survive restarts**.

## Acceptance Criteria

1. **AC1 – 主循环使用统一的状态入口并包含风控状态**  
   - 交易主流程在启动时通过单一入口加载状态（推荐使用 `core.state.load_state()` 或等效封装），在迭代过程中通过统一的保存函数（例如 `core.state.save_state()` 或等效封装）持久化状态。  
   - `portfolio_state.json` 中始终包含 `risk_control` 顶级字段，其结构与 `RiskControlState.to_dict()` 一致。  
   - 当状态文件缺失或损坏时，风控状态会回退到安全默认值，不阻止 Bot 启动（与 Tech Spec AC-7.1.3 对齐）。

2. **AC2 – `_run_iteration()` 在开始阶段调用风控检查入口**  
   - 在每次 `_run_iteration()` 开始阶段（在行情拉取 / 策略分析 / LLM 调用之前），调用风控检查入口函数（例如 `check_risk_limits(...)` 或等效函数），该函数位于 `core` 层或 `core.risk_control` 相关模块中。  
   - 当 `RISK_CONTROL_ENABLED=False` 时，风控检查入口会被跳过或退化为 no-op，并在启动日志中明确记录当前风控总开关状态。  
   - 当前 Story 仅要求预留统一入口与调用时机，具体 Kill-Switch / 每日亏损逻辑由后续 Epic 7.2 / 7.3 实现。

3. **AC3 – 风控状态在迭代生命周期内被一致地加载与保存（PRD FR2/FR4 映射）**  
   - 在 Bot 启动时，风控状态从 `portfolio_state.json` 中恢复一次，并与内存中的交易状态（余额、持仓、迭代计数器）保持一致。  
   - 每次迭代结束时，风控状态与交易状态一并被保存，确保在异常退出 / 重启后能恢复到最近一次迭代的风控状态。  
   - 单元 / 集成测试覆盖以下场景：
     - 有 `risk_control` 字段的状态文件 → 恢复后继续迭代，风控状态保持一致；  
     - 无 `risk_control` 字段的旧文件 → 恢复后使用默认风控状态且不抛异常；  
     - 在多次迭代后重启 Bot，验证风控状态按预期保留。

4. **AC4 – 与现有主循环与架构分层保持一致**  
   - 集成方式与 `docs/architecture/03-data-flow.md` / `06-project-structure-and-mapping.md` 中的分层一致：风控检查被插入在「数据输入阶段」之后、「策略分析阶段」之前，且实现位于 `core/` 层。  
   - 不在 `strategy/`、`llm/` 或 `execution/` 层中直接访问状态文件路径或环境变量，所有风控相关状态读写通过 `core.state` / `core.persistence` 提供的接口完成。  
   - 现有 `tests` 目录下关于交易循环与状态管理的测试在启用风控集成后仍然通过（允许根据需要更新期望值，但不改变外部行为契约）。

5. **AC5 – 测试与可观测性**  
   - 在 `tests/test_risk_control_integration.py`（或等价文件）中新增测试，验证：
     - 主循环在每次迭代开始时至少调用一次风控检查入口（可通过 monkeypatch 计数或日志断言实现）。  
     - 当 `RISK_CONTROL_ENABLED` 为 `False` 时，风控入口被跳过但主循环仍能正常运行。  
   - 日志中在启动阶段输出风控配置与当前状态摘要（例如是否启用、`kill_switch_active` 初始值等），支持后续问题排查（对应 PRD 的可观测性要求）。

## Tasks / Subtasks

- [x] **Task 1 – 统一状态加载与保存路径（AC1, AC3, AC4）**  
  - [x] 1.1 复用 `core.state.load_state()` / `core.state.save_state()` 或等效封装，作为交易主流程的唯一状态入口，避免在 `bot.py` 中直接调用 `core.persistence.load_state_from_json()` / `save_state_to_json()`。  
  - [x] 1.2 确保统一入口在读写时总是包含 `risk_control` 字段，并与 `RiskControlState` 保持结构一致（即便当前风控逻辑尚未启用）。  
  - [x] 1.3 确保所有使用到余额、持仓、迭代计数器的模块（包括 `bot.py` 与 `core/trading_loop.py`）在集成后仍通过 `core.state` 提供的 API 访问状态，不引入新的全局副本。

- [x] **Task 2 – 在 `_run_iteration()` 中插入风控检查入口（AC2, AC3）**  
  - [x] 2.1 在 `_run_iteration()` 的早期阶段（日志头部打印之后、行情与 LLM 调用之前）插入对风控检查入口的调用。  
  - [x] 2.2 风控检查入口函数的签名预留当前账户总权益、迭代时间等参数，以便后续 Epic 7.2 / 7.3 直接利用（例如：Kill-Switch、每日亏损限制）。  
  - [x] 2.3 当 `RISK_CONTROL_ENABLED=False` 时，风控入口直接返回且记录一条 INFO 日志说明「风控已显式关闭」。

- [x] **Task 3 – 保持状态一致性并处理错误路径（AC1, AC3）**  
  - [x] 3.1 验证：状态文件缺失或损坏时，风控状态回退到 `RiskControlState()` 默认值，同时余额与持仓回退到安全默认（例如 `START_CAPITAL` 与空持仓），并记录错误日志。  
  - [x] 3.2 确认：在一次迭代中发生异常并由主循环捕获时，`save_state()` 仍会被调用，从而持久化最新的风控状态。  
  - [x] 3.3 确认：`save_state()` 的实现继续使用原子写入（由 Story 7.1.3 引入），不引入数据损坏风险。

- [x] **Task 4 – 新增 / 扩展测试（AC3, AC5）**  
  - [x] 4.1 在 `tests/test_risk_control_integration.py` 中新增用例：模拟若干迭代后重启 Bot，验证风控状态被正确恢复。  
  - [x] 4.2 为 `_run_iteration()` 增加集成测试或高层测试，验证风控检查入口在每次迭代开始时被调用一次。  
  - [x] 4.3 补充日志相关断言（如使用 `caplog`），验证启动时输出风控配置摘要，异常路径不会导致未捕获异常退出。

## Dev Notes

### Requirements & Context Summary

- 本 Story 对应 **Epic 7.1: 风控状态管理基础设施** 中的 **Story 7.1.4: 集成风控状态到主循环**：
  - 目标：将已定义的 `RiskControlState` 与持久化机制真正「挂入」交易主循环，使风控状态在每次迭代中可用，并在重启后保持一致。  
  - 范围：只处理「状态集成与生命周期管理」：统一加载 / 保存、插入风控检查入口、确保与现有架构分层一致；不实现具体 Kill-Switch 或每日亏损限制逻辑（留给 Epic 7.2/7.3）。
- 与 PRD《风控系统增强 - 产品需求文档》中的对应条目：
  - **FR1–FR4：风控状态管理**：全局 `RiskControlState`、迭代开始/结束加载与保存、持久化到 `portfolio_state.json` 并在启动时恢复。  
  - **NFR1 / NFR3 / NFR9**：风控检查延迟开销小、状态持久化使用原子写入、防止破坏现有部署，均依赖正确的主循环集成与状态入口统一。
- Tech Spec `tech-spec-epic-7-1.md` 中的关键约束：
  - `RiskControlState` 结构与 `risk_control` 顶级字段结构应保持一致。  
  - 风控检查应插入在「数据输入阶段」之后、「策略分析阶段」之前。  
  - 风控配置通过 `config/settings.py` 中的环境变量控制（Story 7.1.2 已实现）。

### Learnings from Previous Story

**From Story 7-1-3-实现风控状态持久化 (Status: done)**

- **New Files / Structures**  
  - 新增 `tests/test_risk_control_integration.py`，为状态持久化与恢复路径提供集成测试样例，包括：
    - 从包含 `risk_control` 字段的 JSON 恢复风控状态；  
    - 从不包含 `risk_control` 字段的旧 JSON 恢复时的兼容行为；  
    - 原子写入失败时不破坏原有状态文件。  
  - 在 `core/state.py` 中引入了 `risk_control_state: RiskControlState` 全局实例，并在 `load_state()` / `save_state()` 中负责 `risk_control` 字段的读写与日志输出。  
  - 在 `core/persistence.py` 中实现了 `save_state_to_json()` 的原子写入逻辑（写临时文件再 `Path.replace()`）。

- **Patterns to Reuse**  
  - **单一持久化入口**：所有状态文件写入通过 `core.persistence.save_state_to_json()` 进行，调用方只需构造完整 payload。  
  - **向后兼容策略**：在加载状态时，对缺失字段使用默认值，并通过日志显式记录兼容路径。  
  - **日志模式**：使用 INFO 级别记录成功加载 / 保存事件，ERROR 级别记录解析失败，并在出错时回退到安全默认状态。

- **Implications for This Story**  
  - 本 Story 在集成主循环时应避免重复实现 JSON 读写或手动解析 `risk_control` 字段，而是复用 `core.state` / `core.persistence` 已经建立的模式。  
  - 新增的风控检查入口应假定 `risk_control_state` 已在启动时正确加载，并在异常情况下依赖 `core.state.load_state()` 的容错行为。  
  - 任何新的日志与测试应尽量复用 7.1.3 中使用的结构与工具（例如 `tests/test_risk_control_integration.py` 的测试夹具与 helper）。

### Architecture & Implementation Constraints

- **模块边界与分层**  
  - 风控状态对象与持久化逻辑集中在 `core/state.py` 与 `core/risk_control.py` 中。  
  - 交易主循环相关逻辑位于 `bot.py` 与 `core/trading_loop.py`，应通过 `core.state` 提供的 API 获取 / 更新状态，而不是直接操作 JSON 文件。  
  - 不在 `strategy/`、`llm/`、`execution/` 等层级使用文件路径或环境变量，这些层只依赖抽象接口（例如 `get_balance()`, `get_positions()` 等）。

- **现有实现现状（在本 Story 之前）**  
  - `core/state.py` 已负责从 `portfolio_state.json` 加载 / 保存 `risk_control` 字段，并在缺失或解析失败时回退到默认 `RiskControlState`。  
  - `bot.py` 以及 `core/trading_loop.py` 目前已有自己的状态访问与保存路径（包括局部的 `load_state_from_json()` / `save_state_to_json()` 调用），但尚未将风控状态检查挂入 `_run_iteration()`。  
  - 部分模块仍然假定状态文件中只有 `balance` / `positions` / `iteration` 等字段，需要在测试中确认增加 `risk_control` 字段不会破坏这些假设。

- **实现约束**  
  - 避免在多个模块中维护状态的「平行副本」；当需要在主循环中访问风控状态时，优先通过 `core.state` 模块中的全局 `risk_control_state` 或后续公开的访问器函数。  
  - 遵循 `docs/architecture/07-implementation-patterns.md` 中关于错误处理和日志的模式：网络 / I/O 错误记录日志但尽量不导致进程退出。

### Project Structure Notes

- 预期受影响文件：  
  - `bot.py` —— 在启动阶段与 `_run_iteration()` 中集成统一的状态加载 / 保存与风控检查入口。  
  - `core/state.py` —— 如有需要，可轻微调整以暴露访问 `risk_control_state` 的辅助函数，或确保与主循环集成后的状态一致性。  
  - `core/trading_loop.py` —— 确保其使用的状态 API 与新的风控集成保持一致（例如调用 `save_state()` 时一并保存风控状态）。  
  - `tests/test_risk_control_integration.py` —— 扩展集成测试覆盖主循环集成与重启场景。

- 不直接修改但需要保持兼容的文件：  
  - `docs/architecture/03-data-flow.md` —— 描述了从数据输入到状态持久化的整体数据流，本 Story 需要在实现中对齐其风控插入点。  
  - `docs/architecture/06-project-structure-and-mapping.md` —— 将「数据持久化与日志」映射到 `core/state.py` 与 `core/persistence.py`，本 Story 不应引入新的持久化位置。  
  - `docs/prd-risk-control-enhancement.md` 与 `docs/epic-risk-control-enhancement.md` —— 后续 Story（Epic 7.2–7.4）会基于本 Story 提供的集成点继续实现 Kill-Switch、每日亏损限制和 Telegram 命令。

### References

- [Source: docs/sprint-artifacts/tech-spec-epic-7-1.md#Acceptance-Criteria-Authoritative]
- [Source: docs/epic-risk-control-enhancement.md#Story-7.1.4-集成风控状态到主循环]
- [Source: docs/prd-risk-control-enhancement.md#功能需求]
- [Source: docs/architecture/03-data-flow.md]
- [Source: docs/architecture/06-project-structure-and-mapping.md]
- [Source: docs/architecture/07-implementation-patterns.md]
- [Source: docs/sprint-artifacts/7-1-1-定义-riskcontrolstate-数据结构.md]
- [Source: docs/sprint-artifacts/7-1-2-添加风控相关环境变量.md]
- [Source: docs/sprint-artifacts/7-1-3-实现风控状态持久化.md]

## Dev Agent Record

### Context Reference

- [7-1-1-定义-riskcontrolstate-数据结构.context.xml]
- [7-1-2-添加风控相关环境变量.context.xml]
- [7-1-3-实现风控状态持久化.context.xml]
- [7-1-4-集成风控状态到主循环.context.xml]
- [tech-spec-epic-7-1.context.xml]（如存在，由 Story Context 工作流生成）

### Agent Model Used

- Claude 3.5 Sonnet (Cascade)

### Debug Log References (Planned)

- 启动阶段：
  - `Risk control config: enabled={}, daily_loss_limit_enabled={}, daily_loss_limit_pct={}%`  
  - `Risk control state loaded: kill_switch_active={}, daily_loss_pct={:.2f}%`
- 迭代阶段：
  - 在 `_run_iteration()` 开始时记录是否执行了风控检查入口以及当前迭代编号。  
  - 当 `RISK_CONTROL_ENABLED=False` 时记录一条 INFO 日志，说明风控被显式关闭。  
  - 异常路径：迭代中出现未预期异常时，记录错误并在 finally/异常处理逻辑中调用 `save_state()`。

### Completion Notes List

- ✅ **实现完成** (2025-11-30)
- 统一了 `bot.py` 与 `core/state.py` 的状态加载/保存路径，`bot.load_state()` 和 `bot.save_state()` 现在委托给 `core.state` 的统一入口
- 在 `core/risk_control.py` 中添加了 `check_risk_limits()` 风控检查入口函数，预留了 `total_equity` 和 `iteration_time` 参数供 Epic 7.2/7.3 使用
- 在 `_run_iteration()` 中插入了风控检查调用，位于日志头部之后、SL/TP 检查之前
- 在 `main()` 中添加了风控配置和状态的启动日志
- 扩展了 `tests/test_risk_control_integration.py`，新增了 `RiskControlCheckIntegrationTests` 和 `RiskControlStateRestartTests` 测试类
- 更新了 `tests/test_state_management.py` 以适配新的状态管理架构
- 所有 420 个测试通过，无回归

### File List

**Modified:**
- `bot.py` – 集成统一状态入口与风控检查调用，添加风控配置日志
- `core/risk_control.py` – 添加 `check_risk_limits()` 风控检查入口函数
- `tests/test_risk_control_integration.py` – 新增 `RiskControlCheckIntegrationTests` 和 `RiskControlStateRestartTests` 测试类
- `tests/test_state_management.py` – 更新以适配新的状态管理架构

---

## Change Log

| 版本 | 日期 | 作者 | 变更说明 |
|------|------|------|----------|
| 0.1 | 2025-11-30 | Bob (SM) | 初始 Story 草稿（通过 *create-story 工作流生成） |
| 1.0 | 2025-11-30 | Dev Agent (Cascade) | 实现完成：统一状态入口、风控检查集成、测试扩展 |
| 1.1 | 2025-11-30 | Senior Dev Review (AI) | Code Review 通过，状态更新为 done |

---

## Senior Developer Review (AI)

### Reviewer
Nick (via Cascade AI)

### Date
2025-11-30

### Outcome
**✅ APPROVE** - 所有验收标准已满足，所有任务已验证完成，无阻塞问题。

### Summary
Story 7.1.4 成功将风控状态集成到主交易循环中。实现质量高，代码结构清晰，测试覆盖全面。所有 420 个测试通过，无回归。

### Key Findings

**无 HIGH 或 MEDIUM 严重性问题。**

**LOW 严重性建议：**
- `core/risk_control.py:15-16` 中的 `TYPE_CHECKING` 导入块引用了自身模块，这是不必要的，但不影响功能。

### Acceptance Criteria Coverage

| AC# | 描述 | 状态 | 证据 |
|-----|------|------|------|
| AC1 | 主循环使用统一的状态入口并包含风控状态 | ✅ IMPLEMENTED | `bot.py:219-231`, `bot.py:248-259`, `core/state.py:141-150` |
| AC2 | `_run_iteration()` 在开始阶段调用风控检查入口 | ✅ IMPLEMENTED | `bot.py:592-598`, `core/risk_control.py:77-124` |
| AC3 | 风控状态在迭代生命周期内被一致地加载与保存 | ✅ IMPLEMENTED | `bot.py:548-559`, `bot.py:628`, `bot.py:566,570` |
| AC4 | 与现有主循环与架构分层保持一致 | ✅ IMPLEMENTED | 风控检查位于 `core/` 层，调用点在数据输入后、策略分析前 |
| AC5 | 测试与可观测性 | ✅ IMPLEMENTED | `tests/test_risk_control_integration.py:168-334` |

**Summary: 5 of 5 acceptance criteria fully implemented**

### Task Completion Validation

| Task | 标记状态 | 验证状态 | 证据 |
|------|----------|----------|------|
| 1.1 复用 core.state.load_state()/save_state() | [x] | ✅ VERIFIED | `bot.py:219-231`, `bot.py:248-259` |
| 1.2 确保 risk_control 字段一致 | [x] | ✅ VERIFIED | `core/state.py:148` |
| 1.3 通过 core.state API 访问状态 | [x] | ✅ VERIFIED | `bot.py:73-83`, `bot.py:87-90` |
| 2.1 在 _run_iteration() 早期插入风控检查 | [x] | ✅ VERIFIED | `bot.py:592-598` |
| 2.2 风控检查入口预留参数 | [x] | ✅ VERIFIED | `core/risk_control.py:77-82` |
| 2.3 RISK_CONTROL_ENABLED=False 时跳过并记录日志 | [x] | ✅ VERIFIED | `core/risk_control.py:104-106` |
| 3.1 状态文件缺失/损坏时回退到默认值 | [x] | ✅ VERIFIED | `core/state.py:72-75`, `core/state.py:92-98` |
| 3.2 异常时 save_state() 仍被调用 | [x] | ✅ VERIFIED | `bot.py:568-570` |
| 3.3 save_state() 使用原子写入 | [x] | ✅ VERIFIED | `core/persistence.py:134-157` |
| 4.1 新增重启后状态恢复测试 | [x] | ✅ VERIFIED | `tests/test_risk_control_integration.py:244-334` |
| 4.2 验证风控检查入口被调用 | [x] | ✅ VERIFIED | `tests/test_risk_control_integration.py:171-189` |
| 4.3 日志相关断言 | [x] | ✅ VERIFIED | `tests/test_risk_control_integration.py:191-202` |

**Summary: 12 of 12 completed tasks verified, 0 questionable, 0 falsely marked complete**

### Test Coverage and Gaps

- **测试通过**: 420/420 (100%)
- **新增测试类**: `RiskControlCheckIntegrationTests`, `RiskControlStateRestartTests`
- **测试覆盖场景**:
  - 风控状态持久化和恢复
  - 旧版本 JSON 文件兼容性
  - 风控检查入口调用
  - RISK_CONTROL_ENABLED=False 时的行为
  - 模拟重启后状态恢复
  - Kill-Switch 状态跨重启保持

### Architectural Alignment

- ✅ 风控检查位于 `core/` 层 (`core/risk_control.py`)
- ✅ 调用点在数据输入阶段之后、策略分析阶段之前
- ✅ 状态管理通过 `core/state.py` 统一入口
- ✅ 不在 `strategy/`、`llm/`、`execution/` 层直接访问状态文件

### Security Notes

- ✅ 风控配置通过环境变量注入，不硬编码
- ✅ 状态持久化使用原子写入防止数据损坏
- ✅ 默认值安全：`RISK_CONTROL_ENABLED=true`, `KILL_SWITCH=false`

### Best-Practices and References

- [Python dataclasses](https://docs.python.org/3/library/dataclasses.html) - 用于 `RiskControlState`
- [Atomic file writes](https://docs.python.org/3/library/pathlib.html#pathlib.Path.replace) - 用于状态持久化

### Action Items

**Advisory Notes:**
- Note: `core/risk_control.py:15-16` 中的 `TYPE_CHECKING` 导入块可以移除，因为它引用了自身模块（无需操作，不影响功能）
