<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>7.1</epicId>
    <storyId>7.1.3</storyId>
    <title>实现风控状态持久化</title>
    <status>drafted</status>
    <generatedAt>2025-11-30T10:09:00+08:00</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/7-1-3-实现风控状态持久化.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>system</asA>
    <iWant>risk control state to persist across restarts</iWant>
    <soThat>risk limits remain enforced even after bot restarts</soThat>
    <tasks>
      <![CDATA[
- Task 1 – 扩展 save_state 持久化 risk_control 字段（AC1, AC5）
  - 1.1 在 core/state.py 中引入全局 risk_control_state 实例（类型为 RiskControlState）。
  - 1.2 在 save_state() 构建 payload 时，将 risk_control_state.to_dict() 作为 risk_control 顶级字段写入。
  - 1.3 确保未显式初始化风控状态时也有安全默认值（例如模块级默认实例）。

- Task 2 – 扩展 load_state 从 JSON 恢复 risk_control 字段（AC2, AC5）
  - 2.1 在 load_state() 中读取 JSON 时，检查 "risk_control" 是否存在且为字典。
  - 2.2 若存在：调用 RiskControlState.from_dict() 恢复风控状态。
  - 2.3 若不存在：记录一条 INFO 日志，说明「旧版本状态文件，使用默认风控状态」。
  - 2.4 加载过程中出现解析错误时：捕获异常、记录 ERROR 日志，并回退到默认风控状态，不影响 Bot 启动。

- Task 3 – 在 core/persistence.py 中实现原子写入（AC3）
  - 3.1 修改 save_state_to_json()：写入到临时文件（例如 state_json.with_suffix(".tmp")）。
  - 3.2 保证在 json.dump() 成功后再使用 Path.replace() 将临时文件替换正式文件。
  - 3.3 发生异常时删除临时文件并记录错误日志，不覆盖原有状态文件。
  - 3.4 添加必要的 try/except，使用现有日志模式（logging.error）。

- Task 4 – 为风控状态持久化新增单元测试（AC4）
  - 4.1 为 RiskControlState 持久化路径编写集成测试（建议：tests/test_risk_control_integration.py）。
  - 4.2 测试从包含 risk_control 字段的 JSON 恢复完整状态。
  - 4.3 测试从不包含 risk_control 字段的 JSON 恢复时的兼容行为。
  - 4.4 使用临时目录 / 文件模拟原子写入过程，验证异常时原始文件未损坏。
  - 4.5 在测试中复用已有的 RiskControlState 单测模式和配置加载单测模式。

- Task 5 – 文档与结构检查（AC5）
  - 5.1 确认新的 risk_control 字段符合 docs/sprint-artifacts/tech-spec-epic-7-1.md 中的示例结构。
  - 5.2 确认 docs/prd-risk-control-enhancement.md 中关于状态持久化的 FR1–FR4 已被满足或明确映射到本 Story。
  - 5.3 如有必要，在后续架构文档或 Epic 文档中补充「状态 JSON 中新增 risk_control 顶级字段」的说明。
      ]]>
    </tasks>
  </story>

  <acceptanceCriteria>
    <![CDATA[
1. AC1 – 在状态 JSON 中持久化 RiskControlState：在 core/state.py 的 save_state() 中，将风控状态序列化为 risk_control 顶级字段写入 JSON，使用 core.risk_control.RiskControlState.to_dict() 生成可 JSON 序列化的字典。
2. AC2 – 从状态 JSON 中恢复 RiskControlState，兼容旧版本文件：在 core/state.py 的 load_state() 中，若存在 risk_control 字段则使用 RiskControlState.from_dict() 恢复，否则使用默认值初始化，并在异常时回退到安全默认。
3. AC3 – 使用原子写入保存状态文件：在 core/persistence.py 的 save_state_to_json() 中，通过临时文件 + Path.replace() 实现原子写入，异常时不破坏原有文件。
4. AC4 – 单元测试覆盖风控状态持久化与兼容性：新增/扩展 tests/test_risk_control_integration.py 覆盖持久化、恢复、兼容性与异常场景。
5. AC5 – 与现有状态结构和业务逻辑保持兼容：不改变 balance、positions、iteration 字段语义与格式，不影响回测与 Dashboard 读取逻辑。
    ]]>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-7-1.md</path>
        <title>Epic 技术规格: 风控状态管理基础设施</title>
        <section>Overview</section>
        <snippet>本技术规格定义 Epic 7.1「风控状态管理基础设施」的详细设计，为 DeepSeek Paper Trading Bot 建立风控系统的数据结构、状态管理和持久化基础设施。</snippet>
      </doc>
      <doc>
        <path>docs/epic-risk-control-enhancement.md</path>
        <title>风控系统增强 - Epic 与 Story 分解</title>
        <section>Epic 7.1 概述</section>
        <snippet>目标: 建立风控系统的数据结构、状态管理和持久化基础设施。范围: 定义 RiskControlState 数据结构，实现状态持久化到 portfolio_state.json，实现状态加载和初始化逻辑，添加风控相关环境变量。</snippet>
      </doc>
      <doc>
        <path>docs/prd-risk-control-enhancement.md</path>
        <title>风控系统增强 - 产品需求文档</title>
        <section>功能需求 - 风控状态管理</section>
        <snippet>FR1–FR4 要求系统维护全局风控状态（RiskControlState），在每次迭代开始时加载、结束时保存，并将风控状态持久化到 portfolio_state.json 的 risk_control 字段，在 Bot 启动时恢复上次风控状态。</snippet>
      </doc>
      <doc>
        <path>docs/prd.md</path>
        <title>DeepSeek Paper Trading Bot 产品需求文档</title>
        <section>4.2 风险控制与资金管理</section>
        <snippet>产品层面对风险控制的要求包括单笔风险限制、强制止损与止盈、退出规则与资金管理，为后续系统级风控（如 Kill-Switch、每日亏损限制）提供业务背景。</snippet>
      </doc>
      <doc>
        <path>docs/architecture/06-project-structure-and-mapping.md</path>
        <title>架构分片 06 - 项目结构与源码树</title>
        <section>6.2 PRD 功能块到架构组件的映射</section>
        <snippet>core/state.py 负责状态管理，core/persistence.py 负责状态持久化，data/ 目录存放 portfolio_state.* 与 trade_history.csv 等运行时数据，是本 Story 修改的主要落点。</snippet>
      </doc>
      <doc>
        <path>docs/architecture/07-implementation-patterns.md</path>
        <title>架构分片 07 - 实现模式与一致性规则</title>
        <section>7.3 数据与格式模式 / 7.8 测试与校验模式</section>
        <snippet>状态与日志应使用 ISO 8601 UTC 时间戳，持久化结构变更需在架构文档中说明；测试统一放在 tests/ 目录，使用 pytest 风格的 test_*.py 文件，并提供覆盖率目标与 smoke 测试约定。</snippet>
      </doc>
    </docs>

    <code>
      <artifact>
        <path>core/risk_control.py</path>
        <kind>core-module</kind>
        <symbol>RiskControlState</symbol>
        <lines>13-68</lines>
        <reason>定义风控系统的核心状态数据结构，并提供 to_dict()/from_dict() 序列化/反序列化逻辑，是 risk_control 字段的源结构。</reason>
      </artifact>
      <artifact>
        <path>core/state.py</path>
        <kind>state-module</kind>
        <symbol>load_state, save_state</symbol>
        <lines>65-105</lines>
        <reason>负责加载与保存交易全局状态（balance、positions、iteration），本 Story 需要在此处集成 RiskControlState 的读写。</reason>
      </artifact>
      <artifact>
        <path>core/persistence.py</path>
        <kind>persistence-module</kind>
        <symbol>save_state_to_json, load_state_from_json</symbol>
        <lines>128-207</lines>
        <reason>封装状态 JSON 的读写逻辑，本 Story 需在 save_state_to_json 中实现原子写入，并确保未来扩展 risk_control 字段时保持兼容。</reason>
      </artifact>
      <artifact>
        <path>config/settings.py</path>
        <kind>config-module</kind>
        <symbol>RISK_CONTROL_ENABLED, KILL_SWITCH, DAILY_LOSS_LIMIT_ENABLED, DAILY_LOSS_LIMIT_PCT</symbol>
        <lines>592-610</lines>
        <reason>集中管理风控相关环境变量配置和默认值，定义了 RiskControlState 行为的运行时约束与默认安全策略。</reason>
      </artifact>
      <artifact>
        <path>tests/test_risk_control.py</path>
        <kind>test-module</kind>
        <symbol>RiskControlState tests</symbol>
        <lines>1-250</lines>
        <reason>验证 RiskControlState 的默认值、序列化/反序列化与往返行为，为本 Story 的持久化测试提供模式参考。</reason>
      </artifact>
      <artifact>
        <path>tests/test_risk_control_config.py</path>
        <kind>test-module</kind>
        <symbol>risk control config tests</symbol>
        <lines>1-212</lines>
        <reason>测试 RISK_CONTROL_ENABLED、KILL_SWITCH、DAILY_LOSS_LIMIT_ENABLED、DAILY_LOSS_LIMIT_PCT 等配置加载与验证逻辑，确保配置层与持久化层行为一致。</reason>
      </artifact>
    </code>

    <dependencies>
      <ecosystem name="python">
        <package name="python-binance" version="1.0.19" />
        <package name="pandas" version="2.2.3" />
        <package name="numpy" version="2.1.3" />
        <package name="requests" version="2.31.0" />
        <package name="python-dotenv" version="1.0.0" />
        <package name="colorama" version="0.4.6" />
        <package name="streamlit" version="1.38.0" />
        <package name="hyperliquid-python-sdk" version=">=0.9.0" />
        <package name="eth-account" version=">=0.10.0" />
        <package name="ccxt" version="unspecified" />
        <package name="streamlit-autorefresh" version="unspecified" />
        <package name="cryptography" version="unspecified" />
      </ecosystem>
    </dependencies>
  </artifacts>

  <constraints>
    <![CDATA[
- 状态持久化必须使用原子写入，防止 portfolio_state.json 损坏（PRD 风控增强 NFR3）。
- RiskControlState.from_dict() 必须对缺失字段使用默认值，保证向后兼容旧 JSON 文件（tech-spec-epic-7-1）。
- 新增 risk_control 顶级字段时，不得改变 balance、positions、iteration 字段的语义与格式，避免破坏现有消费者（architecture 06, 07）。
- 所有时间戳（如 updated_at 与 kill_switch_triggered_at）统一使用 ISO 8601 UTC 字符串表示（architecture 07）。
- 错误处理应以日志记录为主，状态文件解析失败时回退到安全默认状态，而不是让 Bot 崩溃（tech-spec-epic-7-1, PRD 风控增强）。
    ]]>
  </constraints>

  <interfaces>
    <interface>
      <name>RiskControlState</name>
      <kind>dataclass</kind>
      <signature>class RiskControlState(kill_switch_active: bool, kill_switch_reason: Optional[str], kill_switch_triggered_at: Optional[str], daily_start_equity: Optional[float], daily_start_date: Optional[str], daily_loss_pct: float, daily_loss_triggered: bool)</signature>
      <path>core/risk_control.py</path>
    </interface>
    <interface>
      <name>load_state</name>
      <kind>function</kind>
      <signature>def load_state() -&gt; None</signature>
      <path>core/state.py</path>
    </interface>
    <interface>
      <name>save_state</name>
      <kind>function</kind>
      <signature>def save_state() -&gt; None</signature>
      <path>core/state.py</path>
    </interface>
    <interface>
      <name>save_state_to_json</name>
      <kind>function</kind>
      <signature>def save_state_to_json(state_json: Path, payload: Dict[str, Any]) -&gt; None</signature>
      <path>core/persistence.py</path>
    </interface>
    <interface>
      <name>load_state_from_json</name>
      <kind>function</kind>
      <signature>def load_state_from_json(state_json: Path, start_capital: float, taker_fee_rate: float) -&gt; Tuple[float, Dict[str, Dict[str, Any]], int]</signature>
      <path>core/persistence.py</path>
    </interface>
  </interfaces>

  <tests>
    <standards>
      <![CDATA[
- 测试统一放在 tests/ 目录，文件命名为 test_*.py，使用 pytest / unittest 风格（architecture 07）。
- RiskControlState 有专门的单元测试文件 tests/test_risk_control.py，覆盖默认值、序列化/反序列化与 roundtrip 行为。
- 风控配置有专门的单元测试文件 tests/test_risk_control_config.py，覆盖默认值、环境变量覆盖与非法输入回退。
- 本 Story 需要新增集成测试文件（建议 tests/test_risk_control_integration.py），验证 risk_control 字段在 JSON 层面的读写与兼容性。
      ]]>
    </standards>
    <locations>
      <![CDATA[
- tests/test_risk_control.py
- tests/test_risk_control_config.py
- tests/test_risk_control_integration.py（计划新增）
      ]]>
    </locations>
    <ideas>
      <![CDATA[
- 针对 AC1：构造包含 RiskControlState 实例的内存状态，通过 save_state()/save_state_to_json() 写入 JSON，并断言 JSON 中存在 risk_control 顶级字段且结构与 to_dict() 一致。
- 针对 AC2：分别从包含 risk_control 与不包含该字段的 JSON 文件中调用 load_state()/load_state_from_json()，断言 RiskControlState 被正确恢复或使用默认值初始化，并在异常路径下记录错误日志而不中断启动。
- 针对 AC3：在模拟 json.dump 失败或文件系统异常的情况下，验证原始 portfolio_state.json 未被损坏，且错误被 logging.error 记录。
- 针对 AC4：结合现有 tests/test_risk_control.py 与 tests/test_risk_control_config.py 的模式，新增集成测试验证 end-to-end 的持久化与恢复行为。
      ]]>
    </ideas>
  </tests>
</story-context>
